Bueno, generamos las siguientes fuentes
"
asistencia\asistencia.csv
asistencia\asistencia.json
asistencia\asistencia.xml

calificaciones\calificaciones.csv
calificaciones\calificaciones.json
calificaciones\calificaciones.xml

datos_demograficos\datos_demograficos.csv
datos_demograficos\datos_demograficos.json
datos_demograficos\datos_demograficos.xml
"
que fueron creados con los programas
Generador - Asistencias.py
"
import pandas as pd
import numpy as np
import os
import re

# 1. Generar lista de matrículas desde 1001 hasta 1100
matriculas = list(range(1001, 1101))

# 2. Generar el rango de fechas de lunes a viernes
fechas = pd.date_range(
    start="2025-02-17",
    end="2025-07-04",
    freq="B"  # 'B' = business days (excluye sábados y domingos)
)
# Formatear como dd/mm/YYYY
fechas_str = fechas.strftime("%d/%m/%Y")

# 3. Crear DataFrame vacío con índices = matrículas y columnas = fechas
df = pd.DataFrame(
    index=matriculas,
    columns=fechas_str
)

# 4. Rellenar asistencias de forma aleatoria (“S” o “N”)
np.random.seed(42)  # para reproducibilidad
df[:] = np.random.choice(
    ["S", "N"],
    size=(len(matriculas), len(fechas_str))
)

# 5. Preparar para exportar: convertir el índice en columna “MATRICULA”
df.index.name = "MATRICULA"
df.reset_index(inplace=True)

# --- Nuevas modificaciones solicitadas ---

# A. Borrar un 1% de las asistencias (convertirlas a NaN)
num_filas, num_columnas = df.shape
total_celdas = num_filas * (num_columnas - 1)  # Excluye columna MATRICULA
num_celdas_borrar = int(total_celdas * 0.01)   # 1% del total

if num_celdas_borrar > 0:
    # Generar coordenadas aleatorias sin repetición
    filas_aleatorias = np.random.choice(num_filas, size=num_celdas_borrar, replace=False)
    # Columnas: excluyendo la primera (MATRICULA)
    columnas_aleatorias = np.random.choice(range(1, num_columnas), size=num_celdas_borrar, replace=False)
    
    for i in range(num_celdas_borrar):
        fila = filas_aleatorias[i]
        col = columnas_aleatorias[i]
        df.iat[fila, col] = np.nan

# Convertir todos los NaN a string vacío
df = df.fillna("")

# B. Renombrar columnas de fecha para formato válido (reemplazar / por -)
nuevas_columnas = ['MATRICULA'] + [fecha.replace('/', '-') for fecha in fechas_str]
df.columns = nuevas_columnas

# C. Crear directorio principal si no existe
os.makedirs("data/asistencia", exist_ok=True)

# D. Guardar en tres formatos diferentes (muestreo aleatorio)
# Mezclar el DataFrame
df_muestreo = df.sample(frac=1, random_state=42).reset_index(drop=True)
total_filas = len(df_muestreo)

# Dividir en tres partes aproximadamente iguales
tam_parte = total_filas // 3
partes = [
    df_muestreo.iloc[:tam_parte],
    df_muestreo.iloc[tam_parte:2*tam_parte],
    df_muestreo.iloc[2*tam_parte:]
]

# Función para crear nombres XML válidos
def make_valid_xml_name(col_name: str) -> str:
    # Si empieza por dígito, anteponemos '_'
    if re.match(r'^[0-9]', col_name):
        return "_" + col_name
    return col_name

# Procesar solo el DataFrame para XML
df_xml = partes[1].copy()

# Aplicar solo a las columnas de fecha (dejamos "MATRICULA" igual)
new_cols = []
for c in df_xml.columns:
    if c == "MATRICULA":
        new_cols.append(c)
    else:
        new_cols.append(make_valid_xml_name(c))
df_xml.columns = new_cols

# Guardar cada parte en diferente formato
partes[0].to_csv(r"data/asistencia/asistencia.csv", index=False, encoding="utf-8")
df_xml.to_xml(r"data/asistencia/asistencia.xml", index=False)
partes[2].to_json(r"data/asistencia/asistencia.json", orient="records", indent=4)

print("Proceso completado:")
print(f"- CSV guardado en: data/asistencia/asistencia.csv")
print(f"- XML guardado en: data/asistencia/asistencia.xml")
print(f"- JSON guardado en: data/asistencia/asistencia.json")
"

Generador - Calificaciones.py
"
import pandas as pd
import numpy as np
import os
import re
import random
import csv

# === Parte 1: Generar el archivo CSV original ===
materias_por_semestre = {
    2: [
        "Representación simbólica y angular del entorno",
        "Comunicación activa en inglés",
        "Relación entre compuestos orgánicos y el entorno",
        "Comunicación en los ámbitos escolar y profesional",
        "Emprendimiento e innovación",
        "Manejo de aplicaciones por medios digitales",
        "Desarrollo de pensamiento computacional",
        "Identificación de redes de computadoras",
        "Implementación de interfaces de programación"
    ],
    4: [
        "Análisis derivativo de funciones",
        "Comunicación productiva en inglés",
        "Interpretación de fenómenos físicos de la materia",
        "Desarrollo ciudadano",
        "Desarrollo ágil de sistemas",
        "Aplicación de protocolos de datos",
        "Aplicación de modelos ETL",
        "Análisis de tendencias en datos"
    ],
    6: [
        "Tratamiento de datos y azar",
        "Interpretación de normas de convivencia ambiental",
        "Filosofía",
        "Aplicación de modelos predictivos",
        "Presentación y análisis prescriptivo de los datos",
        "Análisis del lenguaje natural",
        "Gestión de rendimiento de los datos"
    ]
}

matriculas = [str(1001 + i) for i in range(100)]
semestres = [2, 4, 6]
datos = []

for matricula in matriculas:
    semestre = random.choice(semestres)
    registro = {'MATRICULA': matricula, 'SEMESTRE': semestre}
    
    for materia in materias_por_semestre[semestre]:
        registro[materia] = random.randint(0, 100)
    
    datos.append(registro)

todas_materias = []
for semestre in [2, 4, 6]:
    todas_materias.extend(materias_por_semestre[semestre])

# Crear directorio si no existe
os.makedirs("tmp", exist_ok=True)

# Escribir el archivo CSV original
with open(r'tmp\calificaciones.csv', 'w', newline='', encoding='utf-8-sig') as csvfile:
    campos = ['MATRICULA', 'SEMESTRE'] + todas_materias
    writer = csv.DictWriter(csvfile, fieldnames=campos)
    writer.writeheader()
    for registro in datos:
        writer.writerow(registro)

print("Archivo original 'calificaciones.csv' generado exitosamente!")

# === Parte 2: Cargar y ensuciar internamente ===

# Cargar el CSV generado en un DataFrame
df = pd.read_csv(r'tmp\calificaciones.csv', encoding='utf-8-sig')

# Identificar columnas de materias (todas excepto MATRICULA y SEMESTRE)
materias_cols = [col for col in df.columns if col not in ['MATRICULA', 'SEMESTRE']]

# Calcular número de registros a ensuciar (10%)
num_registros = len(df)
num_ensuciar = max(1, int(num_registros * 0.10))  # Al menos 1 registro

# Seleccionar registros aleatorios para ensuciar
registros_ensuciar = np.random.choice(df.index, size=num_ensuciar, replace=False)

# Procesar cada registro seleccionado
for idx in registros_ensuciar:
    # Seleccionar aproximadamente el 30% de las materias para modificar
    num_materias_modificar = max(1, int(len(materias_cols) * 0.30))
    materias_modificar = random.sample(materias_cols, num_materias_modificar)
    
    for materia in materias_modificar:
        # Seleccionar aleatoriamente una operación de ensuciado
        operacion = random.choice(['multiplicar', 'dividir', 'borrar'])
        
        if operacion == 'multiplicar':
            # Multiplicar por 100
            df.at[idx, materia] = df.at[idx, materia] * 100
        elif operacion == 'dividir':
            # Dividir entre 100
            df.at[idx, materia] = df.at[idx, materia] / 100
        elif operacion == 'borrar':
            # Borrar el valor
            df.at[idx, materia] = np.nan

# Convertir NaN a string vacío para consistencia en exportación
df = df.fillna('')

# === Parte 3: Muestreo aleatorio y exportación múltiple ===

# Mezclar el DataFrame ensuciado
df_muestreo = df.sample(frac=1, random_state=42).reset_index(drop=True)
total_filas = len(df_muestreo)

# Dividir en tres partes aproximadamente iguales
tam_parte = total_filas // 3
partes = [
    df_muestreo.iloc[:tam_parte],
    df_muestreo.iloc[tam_parte:2*tam_parte],
    df_muestreo.iloc[2*tam_parte:]
]

# Crear directorios necesarios
os.makedirs("data/calificaciones", exist_ok=True)

# Función para sanitizar nombres XML
def sanitize_xml_name(name):
    # Reemplazar caracteres especiales y espacios por guiones bajos
    sanitized = re.sub(r'[^\w]', '_', name)
    # Asegurar que no empiece con número
    if re.match(r'^\d', sanitized):
        sanitized = 'm_' + sanitized
    return sanitized

# 1. Exportar primera parte como CSV
partes[0].to_csv(r'data/calificaciones/calificaciones.csv', index=False, encoding='utf-8-sig')

# 2. Exportar segunda parte como JSON
partes[1].to_json(r'data/calificaciones/calificaciones.json', orient='records', indent=4, force_ascii=False)

# 3. Exportar tercera parte como XML (con sanitización de nombres)
df_xml = partes[2].copy()

# Sanitizar nombres de columnas para XML
nuevos_nombres = {col: sanitize_xml_name(col) for col in df_xml.columns}
df_xml.rename(columns=nuevos_nombres, inplace=True)

# Construir XML manualmente para mayor control
xml_content = '<?xml version="1.0" encoding="UTF-8"?>\n<calificaciones>\n'

for _, row in df_xml.iterrows():
    xml_content += '  <registro>\n'
    for col_name, value in row.items():
        xml_content += f'    <{col_name}>'
        
        # Manejar diferentes tipos de datos
        if pd.isna(value):
            xml_content += ''
        elif isinstance(value, (int, float)):
            xml_content += str(value)
        else:
            # Escapar caracteres especiales para XML
            if isinstance(value, str):
                value = value.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            xml_content += str(value)
        
        xml_content += f'</{col_name}>\n'
    xml_content += '  </registro>\n'

xml_content += '</calificaciones>'

# Guardar XML con codificación UTF-8
with open(r'data/calificaciones/calificaciones.xml', 'w', encoding='utf-8') as xml_file:
    xml_file.write(xml_content)

print("Proceso completado exitosamente!")
print("Archivos generados:")
print(f"- CSV original: csv{os.sep}calificaciones.csv")
print(f"- Muestra CSV: data{os.sep}calificaciones{os.sep}calificaciones.csv")
print(f"- Muestra JSON: data{os.sep}calificaciones{os.sep}calificaciones.json")
print(f"- Muestra XML: data{os.sep}calificaciones{os.sep}calificaciones.xml")
"

Generador - Datos demograficos.py
"
import pandas as pd
import numpy as np
import os
import re
import random

# === Configuración inicial ===
# Crear directorios necesarios
os.makedirs("tmp", exist_ok=True)
os.makedirs("data/datos_demograficos", exist_ok=True)

# === Leer archivo base ===
# Leer el archivo calificaciones.csv para obtener matrículas y semestres
df_base = pd.read_csv(r'tmp/calificaciones.csv', encoding='utf-8-sig')
# Conservar solo las columnas necesarias
df_base = df_base[['MATRICULA', 'SEMESTRE']]

# === Configuración para datos demográficos ===
nombres_femeninos = [
    'María', 'Ana', 'Sofía', 'Lucía', 'Valentina', 'Camila', 'Ximena', 'Renata',
    'Daniela', 'Gabriela', 'Victoria', 'Isabella', 'Paula', 'Alejandra', 'Fernanda'
]

nombres_masculinos = [
    'Juan', 'Luis', 'Carlos', 'José', 'Miguel', 'Jorge', 'Diego', 'Manuel',
    'Pedro', 'Ricardo', 'Francisco', 'Andrés', 'Antonio', 'Rafael', 'Alejandro'
]

apellidos = [
    'García', 'Rodríguez', 'Martínez', 'Hernández', 'López', 'Pérez', 'González',
    'Sánchez', 'Ramírez', 'Torres', 'Flores', 'Díaz', 'Vázquez', 'Castro', 'Ruiz',
    'Jiménez', 'Mendoza', 'Álvarez', 'Romero', 'Navarro', 'Morales', 'Ortega'
]

paises = {
    'MX': 'Mexicana',
    'US': 'Estadounidense',
    'ES': 'Española',
    'CO': 'Colombiana',
    'AR': 'Argentina',
    'CL': 'Chilena',
    'PE': 'Peruana',
    'EC': 'Ecuatoriana',
    'GT': 'Guatemalteca',
    'CU': 'Cubana'
}

# === Generar datos demográficos ===
datos = []

for _, row in df_base.iterrows():
    matricula = row['MATRICULA']
    semestre = row['SEMESTRE']
    
    # Determinar género y nombre
    genero = random.choice(['F', 'M'])
    if genero == 'F':
        nombre = random.choice(nombres_femeninos)
    else:
        nombre = random.choice(nombres_masculinos)
    
    # Generar apellidos
    apellido_paterno = random.choice(apellidos)
    apellido_materno = random.choice(apellidos)
    
    # Calcular fecha de nacimiento según semestre
    if semestre == 2:
        año_nacimiento = 2009
    elif semestre == 4:
        año_nacimiento = 2008
    else:  # semestre 6
        año_nacimiento = 2007
    
    # Generar mes y día aleatorios
    mes_nacimiento = random.randint(1, 12)
    # Determinar días máximos por mes
    if mes_nacimiento == 2:
        max_dias = 28
    elif mes_nacimiento in [4, 6, 9, 11]:
        max_dias = 30
    else:
        max_dias = 31
    
    dia_nacimiento = random.randint(1, max_dias)
    fecha_nacimiento = f"{dia_nacimiento:02d}/{mes_nacimiento:02d}/{año_nacimiento}"
    
    # Seleccionar nacionalidad
    nacionalidad = random.choice(list(paises.values()))
    
    # Crear registro
    registro = {
        'MATRICULA': matricula,
        'NOMBRE': nombre,
        'APELLIDO_PATERNO': apellido_paterno,
        'APELLIDO_MATERNO': apellido_materno,
        'GENERO': genero,
        'FECHA_NACIMIENTO': fecha_nacimiento,
        'NACIONALIDAD': nacionalidad
    }
    
    datos.append(registro)

# Crear DataFrame
df = pd.DataFrame(datos)

# === Ensuciar datos ===
# Campos a ensuciar
campos_ensuciar = ['NOMBRE', 'GENERO', 'FECHA_NACIMIENTO']

# Calcular número de registros a ensuciar (30%)
num_registros = len(df)
num_ensuciar = max(1, int(num_registros * 0.30))

# Seleccionar registros aleatorios para ensuciar
registros_ensuciar = np.random.choice(df.index, size=num_ensuciar, replace=False)

# Procesar cada registro seleccionado
for idx in registros_ensuciar:
    # Seleccionar aleatoriamente 1-3 campos para borrar
    num_campos_borrar = random.randint(1, 3)
    campos_borrar = random.sample(campos_ensuciar, num_campos_borrar)
    
    for campo in campos_borrar:
        df.at[idx, campo] = ''

# === Exportar a múltiples formatos ===
# Función para sanitizar nombres XML
def sanitize_xml_name(name):
    # Reemplazar caracteres especiales por guiones bajos
    sanitized = re.sub(r'[^\w]', '_', name)
    # Asegurar que no empiece con número
    if re.match(r'^\d', sanitized):
        sanitized = 'col_' + sanitized
    return sanitized

# 1. Exportar como CSV
df.to_csv(r'data/datos_demograficos/datos_demograficos.csv', index=False, encoding='utf-8-sig')

# 2. Exportar como JSON
df.to_json(r'data/datos_demograficos/datos_demograficos.json', orient='records', indent=4, force_ascii=False)

# 3. Exportar como XML
# Sanitizar nombres de columnas para XML
nuevos_nombres = {col: sanitize_xml_name(col) for col in df.columns}
df_xml = df.rename(columns=nuevos_nombres)

# Construir XML manualmente para mayor control
xml_content = '<?xml version="1.0" encoding="UTF-8"?>\n<datos_demograficos>\n'

for _, row in df_xml.iterrows():
    xml_content += '  <registro>\n'
    for col_name, value in row.items():
        xml_content += f'    <{col_name}>'
        
        # Escapar caracteres especiales para XML
        if isinstance(value, str):
            value = value.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        xml_content += str(value)
        
        xml_content += f'</{col_name}>\n'
    xml_content += '  </registro>\n'

xml_content += '</datos_demograficos>'

# Guardar XML con codificación UTF-8
with open(r'data/datos_demograficos/datos_demograficos.xml', 'w', encoding='utf-8') as xml_file:
    xml_file.write(xml_content)

print("Proceso completado exitosamente!")
print("Archivos generados en 'data/datos_demograficos':")
print("- datos_demograficos.csv")
print("- datos_demograficos.json")
print("- datos_demograficos.xml")
"
Ahora quiero usar las siguientes reglas de corrección
"
1. Asistencias: Marcar como N

2. Calificaciones: Usar promedio para sobreescribir calificaciones anormales (100 veces más grande/chica de lo normal) o vacía.

3. Datos demográficos: - Agregar alumno/a dependiendo el género.
                       - Rellenar géneros vacíos tomando en cuenta el nombre (tomando en cuenta que los nombres que usamos fueron:
                       nombres_femeninos = [
    'María', 'Ana', 'Sofía', 'Lucía', 'Valentina', 'Camila', 'Ximena', 'Renata',
    'Daniela', 'Gabriela', 'Victoria', 'Isabella', 'Paula', 'Alejandra', 'Fernanda'
]

nombres_masculinos = [
    'Juan', 'Luis', 'Carlos', 'José', 'Miguel', 'Jorge', 'Diego', 'Manuel',
    'Pedro', 'Ricardo', 'Francisco', 'Andrés', 'Antonio', 'Rafael', 'Alejandro'
]
                       )
                       - Fecha de nacimiento: Establecer al primero de enero del año correspondiente para el semestre del alumno
                       (
                        2 = 2009
                        4 = 2008
                        6 = 2007
                       )
"
Usa los siguientes diccionarios de datos para darte una idea de como estan estructurados los dataframes:
Asistencia
"
MATRICULA	Identificador del alumno
FECHAS (17/02/2025-04/07/2025)	"S" para asistencia, "N" para inasistencia

"

Calificaciones
"
MATRICULA	Identificador del alumno
SEMESTRE	Número de semestre del alumno
MATERIAS	Porcentaje del alumno en dada materia

"

Datos demograficos
"
MATRICULA	Identificador del alumno
NOMBRE	Nombre del alumno
APELLIDO PATERNO	Primer apellido del alumno
APELLIDO MATERNO	Segundo apellido del alumno
GENERO	"F" para femenino, "M" para masculino
FECHA DE NACIMIENTO	En el formato Día/Mes/Año
NACIONALIDAD	Identificador del país de origen del alumno

"

Como deberemos acceder a datos de otras tablas/dataframes para el procesamiento de cada dataframe, lo ideal será trabajar en un procesamiento staging que tome los datos de origen, realice los procesos que te específico y me guarde un csv con todos los datos de todas las tablas mezclados, con la codificación adecuada para mantener caracteres especiales.

Talvez sea una buena idea cambiar S o N de asistencias por True, False. Recuerda que S es True y N es False.

DAME EL CÓDIGO COMPLETO CORRECTO QUE ME HAGA LO QUE TE PIDO. 